/*
 * File:   main.c
 * Author: I14883
 *
 * Created on March 2, 2023, 12:21 PM
 */


#include "xc.h"
#include "stdio.h"
#include "stdbool.h"
#include "port_config.h"
#include "hal/timer1.h"
#include "hal/uart1.h"
#include "hal/pwm.h"
#include "hal/clock.h"
#include "diagnostics.h"
#include "hal/adc.h"
#include "foc/sineTable.h"
#include "foc/control.h"
#include "foc/estim.h"
#include "hal/measure.h"
#include "foc/park.h"
#include "foc/pi.h"
#include "foc/svgen.h"
#include "foc/userparms.h"
#include "foc/estim.h"

#include "hal/board_service.h"
#include "Util.h"
union   
{
    struct
        {
        unsigned RunMotor:1;  /* run motor indication */
        unsigned OpenLoop:1;  /* open loop/clsd loop indication */
        unsigned Btn1Pressed:1; /* btn 1 pressed indication */
        unsigned Btn2Pressed:1; /* btn 2 pressed indication */
        unsigned ChangeMode:1; /* mode changed indication - from open to clsd loop */
        unsigned ChangeSpeed:1; /* speed doubled indication */
        unsigned    :10;
        }bit;
    unsigned short Word;
} uGF;        // general flags
MCAPP_MEASURE_T measureInputs;
MCAPP_MEASURE_T measureInputs1;
float Startup_Ramp_Angle_Rads_Per_Sec = 0; /* ramp angle variable for initial ramp */
unsigned int Startup_Lock_Count = 0; /* lock variable for initial ramp */ 
tCtrlParm CtrlParm;
tPIParm     PIParmQ;        /* parms for PI controlers */
tPIParm     PIParmD;        /* parms for PI controlers */
tPIParm     PIParmQref;     /* parms for PI controlers */
volatile uint16_t adcDataBuffer;
volatile uint16_t adcDataBuffer1;
void CalculateParkAngle(void);
void DoControl( void );
void InitControlParameters(void);
void ResetParameters(void);
void  FluxWeakening(void);
int temp;
short phaseCurrentA;
short phaseCurrentB;
int dutyCycleA;
int dutyCycleB;
int dutyCycleC;

float commandStep;
float temp1, temp2;

float StartupSpeed;
volatile unsigned int tempReset;


int16_t recData[10];

int main(void) 
{
    SetupGPIOPorts();
    InitClock();
    LED1 = 1;
    #ifdef INTERNAL_OPAMP_CONFIG
    OpampConfig();
    #endif
    TIMER1_Initialize();
    TIMER1_InputClockSet();
    TIMER1_PeriodSet(TIMER1_PERIOD_COUNT);
    TIMER1_InterruptPrioritySet(5);
    TIMER1_InterruptFlagClear();
    TIMER1_InterruptEnable(); 
    TIMER1_ModuleStart();
    Init_ADC();
    InitPWMGenerators();  
    DiagnosticsInit();
    InitControlParameters();
    InitEstimParm();
    BoardServiceInit();
    uGF.bit.OpenLoop = 1;
    uGF.bit.ChangeMode = 1;
    uGF.bit.ChangeSpeed = 0;
    uGF.bit.RunMotor =0;
    SincosParm.wmr = 0;
//    SincosParm.openLoop = 1;
    SincosParm.Angle = 0;
    SVGenParm.PWMPeriod = (float)MAX_DUTY;
    
    
    while(1)
    {
        DiagnosticsStepMain();
         BoardService();

            if (IsPressed_Button1())
            {
                if  ((uGF.bit.RunMotor == 1) || (PWM_FAULT_STATUS == 1))
                {
                     ResetParameters();
                }
                else
                {
                    EnablePWMOutputsInverterA();
                    uGF.bit.RunMotor = 1;
                }

            }
            if(IsPressed_Button2())
            {
                if ((uGF.bit.RunMotor == 1) && (uGF.bit.OpenLoop == 0))
                {
                    uGF.bit.ChangeSpeed = !uGF.bit.ChangeSpeed;
                }
            }
            /* LED2 is used as motor run Status */
            LED2 = uGF.bit.RunMotor;
        }

        
    
}

int32_t pot = 0,ia = 0,ib = 0,offset_a = 2047,offset_b = 2047,ia1=0,ib1=0 ;

void __attribute__((__interrupt__, no_auto_psv))HAL_MC1ADCInterrupt(void)
{   
    ia = ADCBUF_IA ;
    ib = ADCBUF_IB ;
    
    pot = ADCBUF_POT;
    ia = (2048-ia);
    ia = ia<<4;
    
    ib = (2048-ib);
    ib = ib<<4;
    
    if(uGF.bit.RunMotor == 1)  
    {
        measureInputs.current.Ia = ia;
        measureInputs.current.Ib = ib;
      
        MCAPP_MeasureCurrentCalibrate(&measureInputs);
        phaseCurrentA =  measureInputs.current.Ia;
        phaseCurrentB = measureInputs.current.Ib; 
          
        ParkParm.Ia = (float)phaseCurrentA*ADC_CURRENT_SCALE;
        ParkParm.Ib = (float)phaseCurrentB*ADC_CURRENT_SCALE;
        
        Clarke();
        
        Park(); 
        
        Estim();
        
        // Calculate control values
        DoControl();
   
        // Calculate qAngle from QEI Module
		CalculateParkAngle();
        
        /* if open loop */
		if(uGF.bit.OpenLoop == 1)
		{
		    /* the speed is given by parkparm */
		    SincosParm.wmr = ParkParm.Angle;
		} 
        else
		{
			/* if closed loop, speed generated by estim */
			SincosParm.wmr = EstimParm.qVelEstim;
        }
        
        SinCos();
        ParkParm.Sin = SincosParm.Sin;
        ParkParm.Cos = SincosParm.Cos;    
     
        
//        ParkParm.Vd = 0;      //values for open loop with constant vd and vq
//        ParkParm.Vq = 0.2;
        
        InvPark();
        
        CalcRefVec();
        
        CalcSVGen();
        
    INVERTERA_PWM_PDC3 = (unsigned int)dPWM3;
    INVERTERA_PWM_PDC2 = (unsigned int)dPWM2;
    INVERTERA_PWM_PDC1 = (unsigned int)dPWM1;
        }
    else{
        
        INVERTERA_PWM_PDC3 = MIN_DUTY;
        INVERTERA_PWM_PDC2  = MIN_DUTY;
        INVERTERA_PWM_PDC1 = MIN_DUTY;
       
    
        }
    
  if (uGF.bit.RunMotor == 0)
        {
            measureInputs.current.Ia = ia;
            measureInputs.current.Ib = ib;
           

        }
       
        if (MCAPP_MeasureCurrentOffsetStatus(&measureInputs) == 0)
        {
            MCAPP_MeasureCurrentOffset(&measureInputs);
        }
        else
        {
            BoardServiceStepIsr(); 
        }
        
        DiagnosticsStepIsr();
        
        adcDataBuffer = AD1DATA0;
    HAL_MC1ADCInterruptFlagClear;
}

void DoControl( void )
{
    if( uGF.bit.OpenLoop )
    {
        // OPENLOOP:  force rotating angle,Vd,Vq
        if( uGF.bit.ChangeMode )
        {
            // just changed to openloop
            uGF.bit.ChangeMode = 0;
            // synchronize angles

            // VqRef & VdRef not used
            CtrlParm.qVqRef = 0;
            CtrlParm.qVdRef = 0;

			/* reinit vars for initial speed ramp */
			Startup_Lock_Count = 0;
			Startup_Ramp_Angle_Rads_Per_Sec = 0;
            StartupSpeed = 0;
            
        }
        
        /* q current reference is equal to the vel reference */
        /* while d current reference is equal to 0 */
        /* for maximum startup torque, set the q current to maximum acceptable */
        /* value represents the maximum peak value */
        CtrlParm.qVqRef    = Q_CURRENT_REF_OPENLOOP;
       	
        // PI control for Q
        PIParmQ.qInMeas = ParkParm.Iq;
        PIParmQ.qInRef  = CtrlParm.qVqRef;
        CalcPI(&PIParmQ);
        ParkParm.Vq = PIParmQ.qOut/DC_BUS_VOLTAGE_DUE_TO_SVM; 

        // PI control for D
        PIParmD.qInMeas = ParkParm.Id;
        PIParmD.qInRef  = CtrlParm.qVdRef;
        CalcPI(&PIParmD);
        ParkParm.Vd = PIParmD.qOut/DC_BUS_VOLTAGE_DUE_TO_SVM;

    } 
    else
    // Closed Loop Vector Control
	{
        if( uGF.bit.ChangeMode )
        {
            // just changed from openloop
            uGF.bit.ChangeMode = 0;
			PIParmQref.qdSum = CtrlParm.qVqRef;
            CtrlParm.qVelRef = END_SPEED_RADS_SEC_SEC_ELEC;
            PIParmD.qInRef = 0.0;
            CtrlParm.qVdRef = 0.0;
            commandStep = 0.0;
	    }             
        
//        CtrlParm.qVdRef = 0;

/* if TORQUE MODE skip the speed controller */                
#ifndef	TORQUE_MODE
         if(uGF.bit.ChangeSpeed == 0){
        CtrlParm.qVelRef = ((pot*(NOMINAL_SPEED_RAD_PER_SEC_ELEC - END_SPEED_RADS_SEC_SEC_ELEC)/4096.0)
                                                     + END_SPEED_RADS_SEC_SEC_ELEC);
         if(CtrlParm.qVelRef > NOMINAL_SPEED_RAD_PER_SEC_ELEC)
            CtrlParm.qVelRef = NOMINAL_SPEED_RAD_PER_SEC_ELEC;
     
         CtrlParm.qVelRefFilt = CtrlParm.qVelRefFilt+
						( ( CtrlParm.qVelRef-CtrlParm.qVelRefFilt)*EstimParm.qVelEstimFilterK );  
          CtrlParm.qVelRef =  CtrlParm.qVelRefFilt;
        CtrlParm.qVdRef = 0;
        
        }
        else {
             CtrlParm.qVelRef = ((pot*(FW_SPEED_RAD_PER_SEC_ELEC - END_SPEED_RADS_SEC_SEC_ELEC)/4096.0)
                                                     + END_SPEED_RADS_SEC_SEC_ELEC);
         if(CtrlParm.qVelRef > FW_SPEED_RAD_PER_SEC_ELEC)
            CtrlParm.qVelRef = FW_SPEED_RAD_PER_SEC_ELEC;
          CtrlParm.qVelRefFilt = CtrlParm.qVelRefFilt+
						( ( CtrlParm.qVelRef-CtrlParm.qVelRefFilt)*EstimParm.qVelEstimFilterK );  
         CtrlParm.qVelRef =  CtrlParm.qVelRefFilt;
            FluxWeakening();  
             }
            
//        CtrlParm.qVelRef = ((pot*(NOMINAL_SPEED_RAD_PER_SEC_ELEC - END_SPEED_RADS_SEC_SEC_ELEC)/4096.0)
//                                                     + END_SPEED_RADS_SEC_SEC_ELEC);
		PIParmQref.qInMeas = EstimParm.qVelEstim;// * (60.0/(NOPOLESPAIRS*2*M_PI));
        
    	PIParmQref.qInRef  = CtrlParm.qVelRef;//* (60.0/(NOPOLESPAIRS*2*M_PI));
    	CalcPI(&PIParmQref);
    	CtrlParm.qVqRef = PIParmQref.qOut;

#else
        CtrlParm.qVqRef = (pot/4095.0); // For current reference from 0.00 Amps to 0.999 Amps
#endif

        
        // PI control for D
        PIParmD.qInMeas = ParkParm.Id;          // This is in Amps
        PIParmD.qInRef  = CtrlParm.qVdRef;      // This is in Amps
        CalcPI(&PIParmD);
        ParkParm.Vd    = PIParmD.qOut/DC_BUS_VOLTAGE_DUE_TO_SVM;          // This is in %. If should be converted to volts, multiply with (DC/2)

        /* dynamic d-q adjustment */
        /* with d component priority */
        /* vq=sqrt (vs^2 - vd^2) */
        /* limit vq maximum to the one resulting from the calculation above */
        temp2 = PIParmD.qOut * PIParmD.qOut;
        temp1 = (DC_BUS_VOLTAGE_DUE_TO_SVM*DC_BUS_VOLTAGE_DUE_TO_SVM) - temp2;
        PIParmQ.qOutMax = sqrt(temp1);        
 
        // PI control for Q
        PIParmQ.qInMeas = ParkParm.Iq;          // This is in Amps
        PIParmQ.qInRef  = CtrlParm.qVqRef;      // This is in Amps
        CalcPI(&PIParmQ);
        ParkParm.Vq    = PIParmQ.qOut/DC_BUS_VOLTAGE_DUE_TO_SVM;          // This is in %. If should be converted to volts, multiply with (DC/2)       
    }
}

void CalculateParkAngle(void)
{
    /* if open loop */
	if(uGF.bit.OpenLoop)	
	{
		/* begin with the lock sequence, for field alignment */
		if (Startup_Lock_Count < LOCK_COUNT_FOR_LOCK_TIME)
			Startup_Lock_Count++;
	    /* then ramp up till the end speed */
		else if (StartupSpeed <= END_SPEED_RADS_SEC_SEC_ELEC)
        {
			//Startup_Ramp_Angle_Rads_Per_Sec+=OPENLOOP_RAMPSPEED_INCREASERATE;
            StartupSpeed += OPENLOOP_RAMPSPEED_INCREASERATE;
        }
		else /* switch to closed loop */
		{
            
            StartupSpeed = END_SPEED_RADS_SEC_SEC_ELEC;
#ifndef OPEN_LOOP_FUNCTIONING
            uGF.bit.ChangeMode = 1;
            uGF.bit.OpenLoop = 0;
           
            
#endif
		}
		/* the angle set depends on startup ramp */
		//ParkParm.Angle += Startup_Ramp_Angle_Rads_Per_Sec;
        ParkParm.Angle = StartupSpeed;
//        if(ParkParm.Angle >= SINGLE_ELEC_ROT_RADS_PER_SEC)
//            ParkParm.Angle = 0;       
	}
	else /* switched to closed loop */
	{
   	    /* in closed loop slowly decrease the offset add to */
   	    /* the estimated angle */
   	    if(EstimParm.RhoOffset>(M_PI/(float)32767))
            EstimParm.RhoOffset = EstimParm.RhoOffset - ((M_PI/(float)32767)) ; 
	}
	return;
}

void InitControlParameters(void)
{

  // ============= PI D Term ===============      
    PIParmD.qKp = D_CURRCNTR_PTERM;       
    PIParmD.qKi = D_CURRCNTR_ITERM;              
    PIParmD.qKc = D_CURRCNTR_CTERM;       
    PIParmD.qOutMax = D_CURRCNTR_OUTMAX;
    PIParmD.qOutMin = -PIParmD.qOutMax;

    InitPI(&PIParmD);

    // ============= PI Q Term ===============
    PIParmQ.qKp = Q_CURRCNTR_PTERM;    
    PIParmQ.qKi = Q_CURRCNTR_ITERM;
    PIParmQ.qKc = Q_CURRCNTR_CTERM;
    PIParmQ.qOutMax = Q_CURRCNTR_OUTMAX;
    PIParmQ.qOutMin = -PIParmQ.qOutMax;

    InitPI(&PIParmQ);

    // ============= PI Qref Term ===============
    PIParmQref.qKp = SPEEDCNTR_PTERM;       
    PIParmQref.qKi = SPEEDCNTR_ITERM;       
    PIParmQref.qKc = SPEEDCNTR_CTERM;       
    PIParmQref.qOutMax = SPEEDCNTR_OUTMAX;   
    PIParmQref.qOutMin = -PIParmQref.qOutMax;

    InitPI(&PIParmQref);
	return;
}

void ResetParameters(void)
{
    /* Make sure ADC does not generate interrupt while initializing parameters*/
	DisableADCInterrupt();
    
#ifdef SINGLE_SHUNT
    /* Initialize Single Shunt Related parameters */
    SingleShunt_InitializeParameters(&singleShuntParam);
    INVERTERA_PWM_TRIGA = ADC_SAMPLING_POINT;
    INVERTERA_PWM_TRIGB = LOOPTIME_TCY>>2;
    INVERTERA_PWM_TRIGC = LOOPTIME_TCY>>1;
    INVERTERA_PWM_PHASE3 = MIN_DUTY;
    INVERTERA_PWM_PHASE2 = MIN_DUTY;
    INVERTERA_PWM_PHASE1 = MIN_DUTY;
#else
    INVERTERA_PWM_TRIGA = ADC_SAMPLING_POINT;
#endif
    /* Re initialize the duty cycle to minimum value */
    INVERTERA_PWM_PDC3 = MIN_DUTY;
    INVERTERA_PWM_PDC2 = MIN_DUTY;
    INVERTERA_PWM_PDC1 = MIN_DUTY;
    
    DisablePWMOutputsInverterA();
    
    /* Stop the motor   */
    uGF.bit.RunMotor = 0;        
    /* Set the reference speed value to 0 */
    CtrlParm.qVelRef = 0;
    /* Restart in open loop */
    uGF.bit.OpenLoop = 1;
    //SincosParm.openLoop = 1;
    /* Change speed */
    uGF.bit.ChangeSpeed = 0;
    /* Change mode */
    uGF.bit.ChangeMode = 1;
    ParkParm.FW_Vq = 0;
    ParkParm.FW_Vd = 0;
    CtrlParm.qVdRefFilt = 0;
    //CtrlParm.eMagFiltered =0;
    /* Initialize PI control parameters */
    InitControlParameters();        
    /* Initialize estimator parameters */
    InitEstimParm();
     SincosParm.wmr = 0;
//    SincosParm.openLoop = 1;
    SincosParm.Angle = 0;
    /* Initialize flux weakening parameters */
   // InitFWParams();
    /* Initialize measurement parameters */
    MCAPP_MeasureCurrentInit(&measureInputs);
  
//    MCAPP_MeasureAvgInit(&measureInputs.MOSFETTemperature,
//            MOSFET_TEMP_AVG_FILTER_SCALE);
    /* Enable ADC interrupt and begin main loop timing */
   HAL_MC1ADCInterruptFlagClear;
    adcDataBuffer = AD1DATA0;
//    adcDataBuffer1 = AD2DATA0;
    EnableADCInterrupt();
}
void  FluxWeakening()
{

    float uQref;
    float umax = DC_BUS_VOLTAGE_DUE_TO_SVM;
 
    if(PIParmD.qOut <= DC_BUS_VOLTAGE_DUE_TO_SVM )
    {
        uQref = UTIL_SquareRootFloat( UTIL_SquareFloat( umax ) - UTIL_SquareFloat( PIParmD.qOut ) );
    }
    else
    {
        uQref = 0.0f;
    }   
    //CtrlParm.qVqRef = uQref;
       // CtrlParm.emag = UTIL_MagnitudeFloat( EstimParm.qEsa, EstimParm.qEsb );
        // int16_t eMagDiff = CtrlParm.emag - CtrlParm.eMagFiltered;
         //CtrlParm.eMagFiltered += (eMagDiff* (EstimParm.qVelEstimFilterK/2.0));
        // CtrlParm.eMagFiltered = CtrlParm.eMagFiltered+
						//( ( CtrlParm.emag-CtrlParm.eMagFiltered)*(EstimParm.qVelEstimFilterK*2) );
        ParkParm.FW_Vd = (NOMINAL_SPEED_RAD_PER_SEC_ELEC -CtrlParm.qVelRefFilt)*(MOTOR_BACK_EMF_CONSTANT_Vpeak_PHASE_RAD_PER_SEC_ELEC);
       // ParkParm.FW_Vd = uQref - UTIL_AbsoluteFloat( CtrlParm.qVqRef ) * MOTOR_PER_PHASE_RESISTANCE  - CtrlParm.eMagFiltered ;
        ParkParm.FW_Vq = UTIL_AbsoluteFloat(CtrlParm.qVelRefFilt ) *MOTOR_PER_PHASE_INDUCTANCE;

      //  
        CtrlParm.qVdRef = UTIL_DivisionFloat(ParkParm.FW_Vd, ParkParm.FW_Vq );
        float idRefDiff = CtrlParm.qVdRef - CtrlParm.qVdRefFilt ;
//
          CtrlParm.qVdRefFilt += (idRefDiff*KFILTER_VELESTIM);
          CtrlParm.qVdRef =  CtrlParm.qVdRefFilt;
         UTIL_SaturateFloat( &CtrlParm.qVdRef, MAX_FW_NEGATIVE_ID_REF , 0.0f );
         
    }
   